#include <stdio.h>


//假如有n个台阶，一次只能上1个台阶或2个台阶，请问走到第n个台阶有几种走法？

/*int i=0;
int f(int n)
{
    i++;
    if (n==1)
    {
        return i;
    }
    else if (n==0)
    {
        return i;
    }
    return f(n-2);
}*/
//我这算的是递归的次数
//写的大错特错

//分析
/*
我们先不用递归，直接枚举：
n=1（只有 1 个台阶）：只能一步上去 → 1 种走法。
n=2（两个台阶）：
    1.走 1 步 + 1 步
    2.直接走 2 步
    → 2 种走法。
n=3：
    1.先走 1 步，剩 2 级台阶（f(2) 种走法）
    2.先走 2 步，剩 1 级台阶（f(1) 种走法）
    → 总共 f(3) = f(2) + f(1) = 2 + 1 = 3 种走法。
n=4：
    1.先走 1 步，剩 3 级台阶（f(3) 种走法）
    2.先走 2 步，剩 2 级台阶（f(2) 种走法）
    → f(4) = f(3) + f(2) = 3 + 2 = 5 种走法。
*/

int f(int n)
{
    if (n==1)
    {
        return 1;
    }
    if (n==2)
    {
        return 2;
    }
    /*if(n==1||n==2)
    {
        return n;
    }

     */
    return f(n-1)+f(n-2);
}

int main(void)
{
    //printf("%d\n",f(6));
    int i;
    scanf("%d",&i);
    printf("f(%d)=%d\n",i,f(i));
    return 0;
}

/*
递归的核心其实可以总结成 三点：
🔹 1. 大问题化小问题（分解思想）
递归的本质就是：
👉 把一个规模大的问题，转化为同样形式的更小问题。
例子：台阶问题
走 n 级台阶 = 先走 1 级 + 剩下 (n-1) 级走法 + 先走 2 级 + 剩下 (n-2) 级走法。
大问题 f(n) 转化成了小问题 f(n-1) 和 f(n-2)。

🔹 2. 终止条件（边界）
递归必须有一个停止点，否则会无限调用，导致栈溢出。
比如：
阶乘 factorial(1)=1
台阶 f(1)=1, f(2)=2
斐波那契 fib(0)=0, fib(1)=1
👉 没有“边界条件”，递归就会无限展开。

🔹 3. 递归公式（规律表达式）
递归必须有一个明确的 递推关系式，能把问题一步一步逼近终止条件。
比如：
阶乘：f(n) = n * f(n-1)
台阶：f(n) = f(n-1) + f(n-2)
求和：f(n) = n + f(n-1)
 */


/*
🔹 ✅ 递归的核心总结公式
一句话：
递归 = 找到大问题和小问题之间的关系 + 设定好终止条件。
换句话说：
化整为零：把大问题拆成更小的问题
逐步逼近：每次递归都离终止条件更近
边界明确：小到不能再分的时候直接返回
 */